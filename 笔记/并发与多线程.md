# 一. 并发基本概念及实现，进程，线程基本概念

## 1.并发、进程、线程的基本概念和综述

并发，线程必须要掌握

### （1）并发

两个或者更多的任务（独立的活动）同时发生：一个程序同时执行多个独立的任务；

单核CPU：某一个时刻只能执行一个任务，操作系统进行调度，每秒钟进行所谓的“任务切换”（**上下文切换**）。**并发假象**，这切换有时间开销，比如操作系统需要保存你切换时的各种状态，比如存到寄存器的数据。

多核CPU：能够实现真正的并行执行多个任务（硬件并发）。

![image-20211225231417198](并发与多线程.assets/image-20211225231417198.png)

抢夺CPU时间片。

### （2）可执行程序

磁盘上的一个文件，win下：.exe的，linux下：有执行权限的文件。

### （3）进程

进程，就是一个可执行程序的 运行

### （4）线程

每个进程（执行起来的可执行程序），都有一个主线程，并且这个主线程是为一个，一个进程只能有一个主线程。

但你执行一个可执行程序，主线程就启动起来了。

运行程序的时候，是进程的主线程来调用main函数的代码。

线程是一个代码执行的通路。

![image-20211226090843909](并发与多线程.assets/image-20211226090843909.png)

除了主线程之外，我们可以创建其他线程，去别的地方。

每创建一个新线程，我们可以在同一时刻，执行不同的事情。

线程不是越多越好，每一个线程都需要一个独立的堆栈空间（1M），线程之间切换要保存很多中间状态，切换回耗费本该属于程序运行的时间。

![image-20211226091631271](并发与多线程.assets/image-20211226091631271.png)



### （5）学习心得

## 2.并发的实现方法

多个进程实现并发

一个进程内多个线程实现并发

### （1）多进程并发

进程间通信：

一台电脑：文件，管道，消息队列，共享内存；

不通电脑：socket通信技术；

### （2）多线程并发

单个进程创建了多个线程。

线程是一个轻量级的进程，每个线程都有自己独立的运行路径；一个进程中的所有线程共享空间（共享内存）；**全局变量**，**引用**，**指针**，都可以在线程之间传递，所以使用多线程开销远远小于多进程。

共享内存带来的问题：数据一致性，线程A和线程B同时访问同一块内存

### （3）总结

- 线程启动更快
- 系统资源开销更小，执行速度更快

## 3.C++11新标准库



# 二、线程启动、结束、创建线程

## 1.范例演示线程运行的开始

- 程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕
- 主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行
- 整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】

### （1）普通函数创建线程

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

void myprint() {
    cout << "子线程----" << endl;

    cout << "我的线程结束了" << endl;
}

int main()
{
    std::cout << "Hello World!\n";
    //(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程
    thread test1(myprint);
    
	//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行
	//join意为汇合，子线程和主线程回合
    test1.join();
	//test1.detach();
    cout << "主线程结束了" << endl;
    return 0;
}
```



(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行 detach:分离，主线程不再与子线程汇合，不再等待子线程 

detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管 （**守护线程**）myThread.detach();



​	(4)joinable()判断是否可以成功使用join()或者detach() 

如果返回true，证明可以调用join()或者detach() 

如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了

### （2）使用类对象创建一线程

后期可以传入参数，这里先不写。。

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

class MM {
public:
    MM(int &i):m_i(i){
        cout << "MM构造函数被执行" << endl;
    }  
    MM(const MM &mm) :m_i(mm.m_i) {
        cout << "MM拷贝构造函数函数被执行" << endl;
    }
    ~MM()
    {
        cout << "~MM析构函数函数被执行" << endl;
    }
    void operator()() {
        cout << "我的线程operator（）开始执行了" << endl;

        cout << "mi 1的值为：" << m_i << endl;
        cout << "mi 2的值为：" << m_i << endl;
        cout << "mi 3的值为：" << m_i << endl;
        cout << "mi 4的值为：" << m_i << endl;
        cout << "mi 5的值为：" << m_i << endl;
        // ***
        cout << "我的线程operator（）执行完毕了" << endl;
    }
public:
    int& m_i;
};

int main()
{
    int num = 5;
    MM mm1(num);
    thread test2(mm1);
    test2.detach();
	// test2.join();
    cout << "主线程结束了" << endl;
    return 0;
}
```

传入引用之后，在类中不会拷贝这个值，如果使用**detach**，子线程与主线程分类，（他们各自执行各自的），当主进程结束时，这个变量就会被释放掉，导致程序出现bug，所以这里我们不能够传入引用（如果要用detach的时候）。

还有一个问题：这里的`thread test2(mm1)`，这个`mm1`这也是在主线程中创建的，那么当主线程结束时,这里会有问题吗？答案是不会有问题，当执行创建线程的时候，会对当前的类对象进行一次拷贝（可以发现调用了拷贝构造函数）。

所以这边不会有一个bug

![image-20211226111250138](并发与多线程.assets/image-20211226111250138.png)





