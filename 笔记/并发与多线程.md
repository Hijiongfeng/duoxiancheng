# 一. 并发基本概念及实现，进程，线程基本概念

## 1.并发、进程、线程的基本概念和综述

并发，线程必须要掌握

### （1）并发

两个或者更多的任务（独立的活动）同时发生：一个程序同时执行多个独立的任务；

单核CPU：某一个时刻只能执行一个任务，操作系统进行调度，每秒钟进行所谓的“任务切换”（**上下文切换**）。**并发假象**，这切换有时间开销，比如操作系统需要保存你切换时的各种状态，比如存到寄存器的数据。

多核CPU：能够实现真正的并行执行多个任务（硬件并发）。

![image-20211225231417198](并发与多线程.assets/image-20211225231417198.png)

抢夺CPU时间片。

### （2）可执行程序

磁盘上的一个文件，win下：.exe的，linux下：有执行权限的文件。

### （3）进程

进程，就是一个可执行程序的 运行

### （4）线程

每个进程（执行起来的可执行程序），都有一个主线程，并且这个主线程是为一个，一个进程只能有一个主线程。

但你执行一个可执行程序，主线程就启动起来了。

运行程序的时候，是进程的主线程来调用main函数的代码。

线程是一个代码执行的通路。

![image-20211226090843909](并发与多线程.assets/image-20211226090843909.png)

除了主线程之外，我们可以创建其他线程，去别的地方。

每创建一个新线程，我们可以在同一时刻，执行不同的事情。

线程不是越多越好，每一个线程都需要一个独立的堆栈空间（1M），线程之间切换要保存很多中间状态，切换回耗费本该属于程序运行的时间。

![image-20211226091631271](并发与多线程.assets/image-20211226091631271.png)



### （5）学习心得

## 2.并发的实现方法

多个进程实现并发

一个进程内多个线程实现并发

### （1）多进程并发

进程间通信：

一台电脑：文件，管道，消息队列，共享内存；

不通电脑：socket通信技术；

### （2）多线程并发

单个进程创建了多个线程。

线程是一个轻量级的进程，每个线程都有自己独立的运行路径；一个进程中的所有线程共享空间（共享内存）；**全局变量**，**引用**，**指针**，都可以在线程之间传递，所以使用多线程开销远远小于多进程。

共享内存带来的问题：数据一致性，线程A和线程B同时访问同一块内存

### （3）总结

- 线程启动更快
- 系统资源开销更小，执行速度更快

## 3.C++11新标准库



# 二、线程启动、结束、创建线程

## 1.范例演示线程运行的开始

- 程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕
- 主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行
- 整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】

### （1）普通函数创建线程

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

void myprint() {
    cout << "子线程----" << endl;

    cout << "我的线程结束了" << endl;
}

int main()
{
    std::cout << "Hello World!\n";
    //(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程
    thread test1(myprint);
    
	//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行
	//join意为汇合，子线程和主线程回合
    test1.join();
	//test1.detach();
    cout << "主线程结束了" << endl;
    return 0;
}
```



(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行 detach:分离，主线程不再与子线程汇合，不再等待子线程 

detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管 （**守护线程**）myThread.detach();



​	(4)joinable()判断是否可以成功使用join()或者detach() 

如果返回true，证明可以调用join()或者detach() 

如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了

### （2）使用类对象创建一线程

后期可以传入参数，这里先不写。。

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

class MM {
public:
    MM(int &i):m_i(i){
        cout << "MM构造函数被执行" << endl;
    }  
    MM(const MM &mm) :m_i(mm.m_i) {
        cout << "MM拷贝构造函数函数被执行" << endl;
    }
    ~MM()
    {
        cout << "~MM析构函数函数被执行" << endl;
    }
    void operator()() {
        cout << "我的线程operator（）开始执行了" << endl;

        cout << "mi 1的值为：" << m_i << endl;
        cout << "mi 2的值为：" << m_i << endl;
        cout << "mi 3的值为：" << m_i << endl;
        cout << "mi 4的值为：" << m_i << endl;
        cout << "mi 5的值为：" << m_i << endl;
        // ***
        cout << "我的线程operator（）执行完毕了" << endl;
    }
public:
    int& m_i;
};

int main()
{
    int num = 5;
    MM mm1(num);
    thread test2(mm1);
    test2.detach();
	// test2.join();
    cout << "主线程结束了" << endl;
    return 0;
}
```

传入**引用**之后，在类中不会拷贝这个值，如果使用**detach**，子线程与主线程分类，（他们各自执行各自的），当主进程结束时，这个变量就会被释放掉，导致程序出现bug，所以这里我们不能够传入引用（如果要用detach的时候）。

**注意**

还有一个问题：这里的`thread test2(mm1)`，这个`mm1`这也是在主线程中创建的，那么当主线程结束时,这里会有问题吗？答案是不会有问题，当执行创建线程的时候，会对当前的类对象进行一次拷贝（可以发现调用了拷贝构造函数）。

**对象是被复制到线程中的。**

所以这边不会有一个bug

![image-20211226111250138](并发与多线程.assets/image-20211226111250138.png)



### （3）使用`lambda`表达式创建线程

`lambda`表达式返回一个函数指针，是一个可以被调用的对象，可以作为线程创建的参数。

```c++
//main函数中
auto lambdaThread = [] {
		cout << "我的线程开始执行了" << endl;
		//-------------
		//-------------
		cout << "我的线程开始执行了" << endl;
	};

	thread myThread(lambdaThread);
	myThread.join();

```

### （4）类的成员函数作为线程的入口地址



```c++
class Data_
{
public:
    void GetMsg(){}
    void SaveMsh(){}
};
//main函数里
    Data_ s;
    //第一个&意思是取址，第二个&意思是引用，相当于std::ref(s)
    //thread oneobj(&Data_::SaveMsh,s)传值也是可以的
    //在其他的构造函数中&obj是不会代表引用的，会被当成取地址
    //调用方式：对象成员函数地址，类实例，[成员函数参数]
	//第二个参数可以传递对象s，也可以传递引用std::ref(s)或&s
	//传递s，会调用拷贝构造函数在子线程中生成一个新的对象
	//传递&，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉
    thread oneobj(&Data_::SaveMsh,&s);
    thread twoobj(&Data_::GetMsg,&s);
    oneobj.join();
    twoobj.join();

```



### （5）智能指针作为线程的入口地址





# 一、线程传参详解，detach（）大坑，成员函数做线程函数

## **1.传递临时对象作为线程参数**

### （1）要避免的陷阱1：

这里的函数的参数为：引用整形 `i` ，以及一个`char*` 指针

当我们使用join的时候，主线程等待子线程结束，然后主线程再结束，这样的情况下，这样的传参就没有什么问题，程序就可以正常执行；

如果使用detach后，主程序退出，在主函数中所申请的临时变量就会被销毁，这样就会有问题。

```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

void printD(const int &i,char *mystring) {
	cout << i << endl;			// 分析可得 i 并不是mvar的引用 这是一个值传递，
								// 即使使用了detach，这个值也是安全的，在主线程结束后 并没有被销毁。
	cout << mystring << endl;
	return;
}

int main() {

	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a string";
	string str = "this is a string";
	thread mythread1(printD, mvar, mybuf);
    
	mythread1.detach();


	cout << "主线程结束" << endl;
	system("pause");
	return 0;
}
```



首先看传递引用的情况：



![image-20211226161617930](并发与多线程.assets/image-20211226161617930.png)

![image-20211226161636919](并发与多线程.assets/image-20211226161636919.png)

我们可以看到`mvar`和`mvary`的地址一样，这是因为`mvary`是`mavr`的引用，

![image-20211226161748324](并发与多线程.assets/image-20211226161748324.png)



进入线程函数中，虽然传递的是引用，但是我们发现，`i`的地址与`mavr`的地址不一样，这是对值进行了一次复制。

所以 我们姑且可以任务传递引用是没有问题的，但是在类中，还是不能传引用。

- ​	`i`不是`mvar`真正的引用，实际上值传递，即使主线程运行完毕了，子线程用`i`仍然是安全的，但仍不推荐传递引用 ，推荐改为`const int i`

再看传递指针的情况：

主函数中`mubuf`数组的地址：

![image-20211226162454505](并发与多线程.assets/image-20211226162454505.png)

线程函数中形参`mystring`的地址为：

![image-20211226162557093](并发与多线程.assets/image-20211226162557093.png)

我们可以看出这两个地址是一样的，如果使用`detach`，主线程退出之后，临时变量就会被销毁，这样程序就产生了`bug`。

### （2）要避免的陷阱2：

简单的把`char*`转为`const string`，还不是绝对的安全。

推荐先创建一个临时对象`thread myThread(myPrint, mvar, string(mybuf));`就绝对安全了。。。。

这里不要使用隐式类型转换，要先构造出一个临时变量，作为线程函数传递进去。

```c++
#include <iostream>
#include <thread>
#include <string>
using namespace std;

void myPrint(const int i, const string& pmybuf)
{
	cout << i << endl;
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	//如果detach了，这样仍然是不安全的
	//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string
	//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。
	thread myThread(myPrint, mvar, mybuf);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}

```



### （3）总结

- 如果传递`int`这种简单类型，推荐使用值传递，不要用引用
- 如果传递类对象，避免使用**隐式类型转换**，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象
- 终极结论：建议不使用`detach`





## 2.临时对象作为线程参数继续讲

### （1）线程ID的概念

- id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样
- 线程id可以用C++标准库里的函数来获取。`std::this_thread::get_id()`来获取



### （2）传入类对象作为线程参数



```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

class A {
public:
	int m_i;
	A(int i) :m_i(i) { cout << "构造函数执行" << this<<" thread_id:" <<this_thread::get_id()<< endl; }
	A(const A& a) :m_i(a.m_i) { cout << "拷贝构造函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl; }
	~A()
	{
		cout << "析构函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl;
	}
};

void myPrint2(const A& pmybuf) {

	cout << "子线程地址" << &pmybuf<<" ";

	cout << "子线程ID：" << this_thread::get_id() << endl;
}

int main() {

	cout << "主线程ID" << this_thread::get_id()<<endl;
	int mavr = 1;
	thread mythread2(myPrint2,mavr);
	mythread2.join();

	return 0;
}
```





​	`thread mythread2(myPrint2,mavr);`注意这一句，发生传入线程函数将发生**隐式类型转换**

执行结果如下图所示：.......这个构造函数发生在子线程中，这就很危险。如果使用detach，可能会发生主线程已经结束了，这个构造还没有开始（是利用主线程中的局部变量进行构造），这就会发生`bug`。

![image-20211226191836914](并发与多线程.assets/image-20211226191836914.png)



`thread mythread2(myPrint2,A(mavr));`采用临时变量传递，执行结果如下图所示：

执行了一次构造函数，拷贝构造函数。传入线程参数内的是是**拷贝出来的对象**，所以在线程函数内部修改内成员函数值，也不会影响主线程内的类对象成员值，这个可以做一个验证。因为它们 **类对象** 的地址不一样。

![image-20211226192719944](并发与多线程.assets/image-20211226192719944.png)



```c++
	//myPrint(const A& pmybuf)中引用不能去掉，如果去掉会多创建一个对象
	//const也不能去掉，去掉会出错
	//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，
	//所以在子线程中修改m_i的值不会影响到主线程
	//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));
	//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了

```



使用`std::ref`结果

![image-20211226193558126](并发与多线程.assets/image-20211226193558126.png)







### （3）传入智能指针作为线程参数



```c++
#include <iostream>
#include <thread>
#include <memory>
using namespace std;

void myPrint(unique_ptr<int> psd)
{
	cout << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	unique_ptr<int> myp(new int(10));
	//独占式指针只能通过std::move()才可以传递给另一个指针
	//传递后up就指向空，新的ptn指向原来的内存
	//所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了
	thread myThread(myPrint, std::move(myp));
	myThread.join();
	//myThread.detach();

	return 0;
}
```



![image-20211226195437339](并发与多线程.assets/image-20211226195437339.png)





![image-20211226195523271](并发与多线程.assets/image-20211226195523271.png)



主线程`myp`智能指针值为空

![image-20211226195703355](并发与多线程.assets/image-20211226195703355.png)



​	所以这时就不能用`detach`了，因为如果主线程先执行完，`myp`指向的对象就被释放了



### （4）类成员函数指针作为线程参数



```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

class A {
public:
	mutable int m_i;
	A(int i) :m_i(i) { cout << "构造函数执行" << this<<" thread_id:" <<this_thread::get_id()<< endl; }
	A(const A& a) :m_i(a.m_i) { cout << "拷贝构造函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl; }
	~A()
	{
		cout << "析构函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl;
	}
	void thread_work(int a) {
		cout << "a = " << a << endl;
		cout << "子线程thread_work执行:" << this<<"  线程ID:"<<this_thread::get_id() << endl;
	}
};

int main() {

	A myobj(10);
	thread mythread4(&A::thread_work, myobj, 100);
    //thread mythread4(&A::thread_work, std::ref(myobj), 100);  // 真引用
	mythread4.join();
	
	return 0;
}
```

​	`thread mythread4(&A::thread_work, myobj, 100);`注意这边传入线程函数是一个类对象，会调用拷贝构造函数，这个时候使用`detach`就是安全的，

![image-20211226202526661](并发与多线程.assets/image-20211226202526661.png)

`thread mythread4(&A::thread_work, std::ref(myobj), 100);` 使用 `std::ref`,传递真引用，这个时候使用`detach`不安全

注意这个时候`&myobj`与`std::ref(myobj)`效果相同，只能用`join`

![image-20211226202821212](并发与多线程.assets/image-20211226202821212.png)
