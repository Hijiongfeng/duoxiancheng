# c+一. 并发基本概念及实现，进程，线程基本概念

## 1.并发、进程、线程的基本概念和综述

并发，线程必须要掌握

### （1）并发

两个或者更多的任务（独立的活动）同时发生：一个程序同时执行多个独立的任务；

单核CPU：某一个时刻只能执行一个任务，操作系统进行调度，每秒钟进行所谓的“任务切换”（**上下文切换**）。**并发假象**，这切换有时间开销，比如操作系统需要保存你切换时的各种状态，比如存到寄存器的数据。

多核CPU：能够实现真正的并行执行多个任务（硬件并发）。

![image-20211225231417198](并发与多线程.assets/image-20211225231417198.png)

抢夺CPU时间片。

### （2）可执行程序

磁盘上的一个文件，win下：.exe的，linux下：有执行权限的文件。

### （3）进程

进程，就是一个可执行程序的 运行

### （4）线程

每个进程（执行起来的可执行程序），都有一个主线程，并且这个主线程是为一个，一个进程只能有一个主线程。

但你执行一个可执行程序，主线程就启动起来了。

运行程序的时候，是进程的主线程来调用main函数的代码。

线程是一个代码执行的通路。

![image-20211226090843909](并发与多线程.assets/image-20211226090843909.png)

除了主线程之外，我们可以创建其他线程，去别的地方。

每创建一个新线程，我们可以在同一时刻，执行不同的事情。

线程不是越多越好，每一个线程都需要一个独立的堆栈空间（1M），线程之间切换要保存很多中间状态，切换回耗费本该属于程序运行的时间。

![image-20211226091631271](并发与多线程.assets/image-20211226091631271.png)



### （5）学习心得

## 2.并发的实现方法

多个进程实现并发

一个进程内多个线程实现并发

### （1）多进程并发

进程间通信：

一台电脑：文件，管道，消息队列，共享内存；

不通电脑：socket通信技术；

### （2）多线程并发

单个进程创建了多个线程。

线程是一个轻量级的进程，每个线程都有自己独立的运行路径；一个进程中的所有线程共享空间（共享内存）；**全局变量**，**引用**，**指针**，都可以在线程之间传递，所以使用多线程开销远远小于多进程。

共享内存带来的问题：数据一致性，线程A和线程B同时访问同一块内存

### （3）总结

- 线程启动更快
- 系统资源开销更小，执行速度更快

## 3.C++11新标准库



# 二、线程启动、结束、创建线程

## 1.范例演示线程运行的开始

- 程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕
- 主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行
- 整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】

### （1）普通函数创建线程

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

void myprint() {
    cout << "子线程----" << endl;

    cout << "我的线程结束了" << endl;
}

int main()
{
    std::cout << "Hello World!\n";
    //(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程
    thread test1(myprint);
    
	//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行
	//join意为汇合，子线程和主线程回合
    test1.join();
	//test1.detach();
    cout << "主线程结束了" << endl;
    return 0;
}
```



(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行 detach:分离，主线程不再与子线程汇合，不再等待子线程 

detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管 （**守护线程**）myThread.detach();



​	(4)joinable()判断是否可以成功使用join()或者detach() 

如果返回true，证明可以调用join()或者detach() 

如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了

### （2）使用类对象创建一线程

后期可以传入参数，这里先不写。。

```c++
#include <iostream>
#include<thread>
#include<string>

using namespace std;

class MM {
public:
    MM(int &i):m_i(i){
        cout << "MM构造函数被执行" << endl;
    }  
    MM(const MM &mm) :m_i(mm.m_i) {
        cout << "MM拷贝构造函数函数被执行" << endl;
    }
    ~MM()
    {
        cout << "~MM析构函数函数被执行" << endl;
    }
    void operator()() {
        cout << "我的线程operator（）开始执行了" << endl;

        cout << "mi 1的值为：" << m_i << endl;
        cout << "mi 2的值为：" << m_i << endl;
        cout << "mi 3的值为：" << m_i << endl;
        cout << "mi 4的值为：" << m_i << endl;
        cout << "mi 5的值为：" << m_i << endl;
        // ***
        cout << "我的线程operator（）执行完毕了" << endl;
    }
public:
    int& m_i;
};

int main()
{
    int num = 5;
    MM mm1(num);
    thread test2(mm1);
    test2.detach();
	// test2.join();
    cout << "主线程结束了" << endl;
    return 0;
}
```

传入**引用**之后，在类中不会拷贝这个值，如果使用**detach**，子线程与主线程分类，（他们各自执行各自的），当主进程结束时，这个变量就会被释放掉，导致程序出现bug，所以这里我们不能够传入引用（如果要用detach的时候）。

**注意**

还有一个问题：这里的`thread test2(mm1)`，这个`mm1`这也是在主线程中创建的，那么当主线程结束时,这里会有问题吗？答案是不会有问题，当执行创建线程的时候，会对当前的类对象进行一次拷贝（可以发现调用了拷贝构造函数）。

**对象是被复制到线程中的。**

所以这边不会有一个bug

![image-20211226111250138](并发与多线程.assets/image-20211226111250138.png)



### （3）使用`lambda`表达式创建线程

`lambda`表达式返回一个函数指针，是一个可以被调用的对象，可以作为线程创建的参数。

```c++
//main函数中
auto lambdaThread = [] {
		cout << "我的线程开始执行了" << endl;
		//-------------
		//-------------
		cout << "我的线程开始执行了" << endl;
	};

	thread myThread(lambdaThread);
	myThread.join();

```

### （4）类的成员函数作为线程的入口地址



```c++
class Data_
{
public:
    void GetMsg(){}
    void SaveMsh(){}
};
//main函数里
    Data_ s;
    //第一个&意思是取址，第二个&意思是引用，相当于std::ref(s)
    //thread oneobj(&Data_::SaveMsh,s)传值也是可以的
    //在其他的构造函数中&obj是不会代表引用的，会被当成取地址
    //调用方式：对象成员函数地址，类实例，[成员函数参数]
	//第二个参数可以传递对象s，也可以传递引用std::ref(s)或&s
	//传递s，会调用拷贝构造函数在子线程中生成一个新的对象
	//传递&，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉
    thread oneobj(&Data_::SaveMsh,&s);
    thread twoobj(&Data_::GetMsg,&s);
    oneobj.join();
    twoobj.join();

```



### （5）智能指针作为线程的入口地址





# 三、线程传参详解，detach（）大坑，成员函数做线程函数

## **1.传递临时对象作为线程参数**

### （1）要避免的陷阱1：

这里的函数的参数为：引用整形 `i` ，以及一个`char*` 指针

当我们使用join的时候，主线程等待子线程结束，然后主线程再结束，这样的情况下，这样的传参就没有什么问题，程序就可以正常执行；

如果使用detach后，主程序退出，在主函数中所申请的临时变量就会被销毁，这样就会有问题。

```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

void printD(const int &i,char *mystring) {
	cout << i << endl;			// 分析可得 i 并不是mvar的引用 这是一个值传递，
								// 即使使用了detach，这个值也是安全的，在主线程结束后 并没有被销毁。
	cout << mystring << endl;
	return;
}

int main() {

	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a string";
	string str = "this is a string";
	thread mythread1(printD, mvar, mybuf);
    
	mythread1.detach();


	cout << "主线程结束" << endl;
	system("pause");
	return 0;
}
```



首先看传递引用的情况：



![image-20211226161617930](并发与多线程.assets/image-20211226161617930.png)

![image-20211226161636919](并发与多线程.assets/image-20211226161636919.png)

我们可以看到`mvar`和`mvary`的地址一样，这是因为`mvary`是`mavr`的引用，

![image-20211226161748324](并发与多线程.assets/image-20211226161748324.png)



进入线程函数中，虽然传递的是引用，但是我们发现，`i`的地址与`mavr`的地址不一样，这是对值进行了一次复制。

所以 我们姑且可以任务传递引用是没有问题的，但是在类中，还是不能传引用。

- ​	`i`不是`mvar`真正的引用，实际上值传递，即使主线程运行完毕了，子线程用`i`仍然是安全的，但仍不推荐传递引用 ，推荐改为`const int i`

再看传递指针的情况：

主函数中`mubuf`数组的地址：

![image-20211226162454505](并发与多线程.assets/image-20211226162454505.png)

线程函数中形参`mystring`的地址为：

![image-20211226162557093](并发与多线程.assets/image-20211226162557093.png)

我们可以看出这两个地址是一样的，如果使用`detach`，主线程退出之后，临时变量就会被销毁，这样程序就产生了`bug`。

### （2）要避免的陷阱2：

简单的把`char*`转为`const string`，还不是绝对的安全。

推荐先创建一个临时对象`thread myThread(myPrint, mvar, string(mybuf));`就绝对安全了。。。。

这里不要使用隐式类型转换，要先构造出一个临时变量，作为线程函数传递进去。

```c++
#include <iostream>
#include <thread>
#include <string>
using namespace std;

void myPrint(const int i, const string& pmybuf)
{
	cout << i << endl;
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	//如果detach了，这样仍然是不安全的
	//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string
	//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。
	thread myThread(myPrint, mvar, mybuf);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}

```



### （3）总结

- 如果传递`int`这种简单类型，推荐使用值传递，不要用引用
- 如果传递类对象，避免使用**隐式类型转换**，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象
- 终极结论：建议不使用`detach`





## 2.临时对象作为线程参数继续讲

### （1）线程ID的概念

- id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样
- 线程id可以用C++标准库里的函数来获取。`std::this_thread::get_id()`来获取



### （2）传入类对象作为线程参数



```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

class A {
public:
	int m_i;
	A(int i) :m_i(i) { cout << "构造函数执行" << this<<" thread_id:" <<this_thread::get_id()<< endl; }
	A(const A& a) :m_i(a.m_i) { cout << "拷贝构造函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl; }
	~A()
	{
		cout << "析构函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl;
	}
};

void myPrint2(const A& pmybuf) {

	cout << "子线程地址" << &pmybuf<<" ";

	cout << "子线程ID：" << this_thread::get_id() << endl;
}

int main() {

	cout << "主线程ID" << this_thread::get_id()<<endl;
	int mavr = 1;
	thread mythread2(myPrint2,mavr);
	mythread2.join();

	return 0;
}
```





​	`thread mythread2(myPrint2,mavr);`注意这一句，发生传入线程函数将发生**隐式类型转换**

执行结果如下图所示：.......这个构造函数发生在子线程中，这就很危险。如果使用detach，可能会发生主线程已经结束了，这个构造还没有开始（是利用主线程中的局部变量进行构造），这就会发生`bug`。

![image-20211226191836914](并发与多线程.assets/image-20211226191836914.png)



`thread mythread2(myPrint2,A(mavr));`采用临时变量传递，执行结果如下图所示：

执行了一次构造函数，拷贝构造函数。传入线程参数内的是是**拷贝出来的对象**，所以在线程函数内部修改内成员函数值，也不会影响主线程内的类对象成员值，这个可以做一个验证。因为它们 **类对象** 的地址不一样。

![image-20211226192719944](并发与多线程.assets/image-20211226192719944.png)



```c++
	//myPrint(const A& pmybuf)中引用不能去掉，如果去掉会多创建一个对象
	//const也不能去掉，去掉会出错
	//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，
	//所以在子线程中修改m_i的值不会影响到主线程
	//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));
	//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了

```



使用`std::ref`结果

![image-20211226193558126](并发与多线程.assets/image-20211226193558126.png)







### （3）传入智能指针作为线程参数



```c++
#include <iostream>
#include <thread>
#include <memory>
using namespace std;

void myPrint(unique_ptr<int> psd)
{
	cout << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	unique_ptr<int> myp(new int(10));
	//独占式指针只能通过std::move()才可以传递给另一个指针
	//传递后up就指向空，新的ptn指向原来的内存
	//所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了
	thread myThread(myPrint, std::move(myp));
	myThread.join();
	//myThread.detach();

	return 0;
}
```



```c++
//独占式指针只能通过std::move()才可以传递给另一个指针
//传递后up就指向空，新的ptn指向原来的内存
//所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了
```



![image-20211226195437339](并发与多线程.assets/image-20211226195437339.png)





![image-20211226195523271](并发与多线程.assets/image-20211226195523271.png)



主线程`myp`智能指针值为空

![image-20211226195703355](并发与多线程.assets/image-20211226195703355.png)



​	所以这时就不能用`detach`了，因为如果主线程先执行完，`myp`指向的对象就被释放了



### （4）类成员函数指针作为线程参数



```c++
#include<iostream>
#include<thread>
#include<string>

using namespace std;

class A {
public:
	mutable int m_i;
	A(int i) :m_i(i) { cout << "构造函数执行" << this<<" thread_id:" <<this_thread::get_id()<< endl; }
	A(const A& a) :m_i(a.m_i) { cout << "拷贝构造函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl; }
	~A()
	{
		cout << "析构函数执行" << this<< " thread_id:" << this_thread::get_id()<<endl;
	}
	void thread_work(int a) {
		cout << "a = " << a << endl;
		cout << "子线程thread_work执行:" << this<<"  线程ID:"<<this_thread::get_id() << endl;
	}
};

int main() {

	A myobj(10);
	thread mythread4(&A::thread_work, myobj, 100);
    //thread mythread4(&A::thread_work, std::ref(myobj), 100);  // 真引用
	mythread4.join();
	
	return 0;
}
```

​	`thread mythread4(&A::thread_work, myobj, 100);`注意这边传入线程函数是一个类对象，会调用拷贝构造函数，这个时候使用`detach`就是安全的，

![image-20211226202526661](并发与多线程.assets/image-20211226202526661.png)

`thread mythread4(&A::thread_work, std::ref(myobj), 100);` 使用 `std::ref`,传递真引用，这个时候使用`detach`不安全

注意这个时候`&myobj`与`std::ref(myobj)`效果相同，只能用`join`

![image-20211226202821212](并发与多线程.assets/image-20211226202821212.png)



# 四、创建多个线程，数据共享问题分析，案例代码

## 1.创建和等待多个线程



```c++
#include<iostream>
#include<thread>
#include<vector>

using namespace std;

void myPrint(int num) { // 线程入口函数

	cout << "子线程开始执行,线程编号: " << num << endl;

	cout << "子线程结束执行,线程编号: " << num << endl;
}


int main() {

	vector<thread> mythread;

	for (int i = 0; i < 10; i++) {
		mythread.push_back(thread(myPrint, i));
	}

	for (auto iter = mythread.begin(); iter != mythread.end(); iter++) {
		iter->join();
	}
	cout << "主线程结束" << endl;

	return 0;
}
```

- 把thread对象放入到容器中管理，看起来像个**thread对象数组**，对一次创建大量的线程并对大量线程进行管理有好处
- 多个线程执行顺序是乱的，跟**操作系统内部对线程的运行调度机制**有关



## 2.数据共享问题分析

### （1）只读的数据



```c++
#include<iostream>
#include<thread>
#include<vector>

using namespace std;

vector<int> gv{ 1 };

void myPrint(int num) { // 线程入口函数

	//cout << "子线程开始执行,线程编号: " << num << endl;

	//cout << "子线程结束执行,线程编号: " << num << endl;

	cout << "线程ID: " << this_thread::get_id() <<"  gv的值："<<gv[0] << endl;  //每个线程都去读gv的值
	return;
}


int main() {

	vector<thread> mythread;

	for (int i = 0; i < 10; i++) {
		mythread.push_back(thread(myPrint, i));
	}

	for (auto iter = mythread.begin(); iter != mythread.end(); iter++) {
		iter->join();
	}
	cout << "主线程结束" << endl;

	//2.1只读的数据

	return 0;
}
```

- 是安全稳定的



### （2）读写数据



- 若不加处理，就会出错
- 最简单的防止崩溃方法：读的时候不能写，写的时候不能读。
- 写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃）



## 3.共享数据保护案例代码

案例：网络游戏服务器，两个自己创建的线程，一个线程收集玩家的命令（数字），并且将命令写到一个队列中；

​																				另一个线程读取玩家命令，从队列中取出，进行解析。



多线程解决数据共享问题，引入一个**“互斥量”**的概念（读的时候不能写，写的时候不能读）。



```c++
#include<iostream>
#include<thread>
#include<vector>
#include<list>

using namespace std;

class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			cout << "inMsgReciveQue: " << i << endl;
			msgReciveque.push_back(i);
		}
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			if (msgReciveque.empty()) {
				cout << "消息队列为空,命令：" << i << endl;
			}
			else
			{
				int com = msgReciveque.front();  // 取元素
				msgReciveque.pop_front();		// 消除
			}
		}
	}

private:
	list<int> msgReciveque;		// 保护共享数据
};


int main() {

	//2.2读写的数据

	A myobj;
	thread mythread_out(&A::outMsgReciveQue, &myobj);	// 取数据
	thread mythread_in(&A::inMsgReciveQue, &myobj);		// 写数据

	mythread_out.join();
	mythread_in.join();

	return 0;
}
```



# 五、互斥量概念、用法、死锁演示及解决详解

## 1.互斥量（mutex）的基本概念

- 互斥量就是个类对象，可以理解为一把锁，多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功，如果没有锁成功，那么流程将卡在lock()这里不断尝试去锁定。
- 互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。



## 2.互斥量的用法

```c++
#include<iostream>
#include<thread>
#include<vector>
#include<list>
#include<mutex>

using namespace std;

class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			cout << "inMsgReciveQue: " << i << endl;
			my_mutex.lock();
			msgReciveque.push_back(i);
			my_mutex.unlock();
		}
	}

	bool outMagLULPro(int& command) {
		my_mutex.lock();
		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除
			my_mutex.unlock();
			return true;
		}
		my_mutex.unlock();
		return false;
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex;
};

int main() {

	A myobj;
	thread mythread_out(&A::outMsgReciveQue, &myobj);
	thread mythread_in(&A::inMsgReciveQue, &myobj);

	mythread_out.join();
	mythread_in.join();

	return 0;
}
```

### （1）lock()，unlock()

步骤：

- 1.`lock()`，

- 2.操作共享数据，

- 3.`unlock()`。

  `lock()`和`unlock()`要成对使用

### （2）lock_guard类模板

`lock_guard<mutex> sbguard(myMutex);`    取代  `lock()`和`unlock()`

`lock_guard`构造函数执行了`mutex::lock()`;在作用域结束时，调用析构函数，执行`mutex::unlock()`

```c++
#include<iostream>
#include<thread>
#include<vector>
#include<list>
#include<mutex>

class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			
			//my_mutex.lock();
			cout << "inMsgReciveQue: " << i << endl;
			{
				lock_guard<mutex> sbguard(my_mutex);
				
				msgReciveque.push_back(i);
			}

			//my_mutex.unlock();
		}
	}

	bool outMagLULPro(int& command) {
		lock_guard<mutex> sbguard(my_mutex);		//  lock_guard 构造函数里面 进行lock，析构函数 执行unlock
		//my_mutex.lock();
		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除
			//my_mutex.unlock();
			return true;
		}
		//my_mutex.unlock();
		return false;
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex;				// 一个互斥量就是 一把锁
};


int main() {

	A myobj;
	thread mythread_out(&A::outMsgReciveQue, &myobj);
	thread mythread_in(&A::inMsgReciveQue, &myobj);

	mythread_out.join();
	mythread_in.join();

	return 0;
}
```

## 3.死锁



### （1）死锁演示

![image-20211227141123364](并发与多线程.assets/image-20211227141123364.png)



```c++
#include<iostream>
#include<thread>
#include<vector>
#include<list>
#include<mutex>

using namespace std;

class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			
			//my_mutex.lock();
			cout << "inMsgReciveQue: " << i << endl;
			{
				//lock_guard<mutex> sbguard(my_mutex);
				my_mutex1.lock();
				my_mutex2.lock();
				msgReciveque.push_back(i);
				my_mutex2.unlock();
				my_mutex1.unlock();

			}

			//my_mutex.unlock();
		}
	}

	bool outMagLULPro(int& command) {
		//lock_guard<mutex> sbguard(my_mutex);		//  lock_guard 构造函数里面 进行lock，析构函数 执行unlock
		my_mutex2.lock();
		my_mutex1.lock();
		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除
			my_mutex1.unlock();
			my_mutex2.unlock();
			return true;
		}
		//my_mutex.unlock();
		my_mutex1.unlock();
		my_mutex2.unlock();
		return false;
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;			// 需要两个互斥量
	mutex my_mutex2;
};

int main() {
    
	A myobj;
	thread mythread_out(&A::outMsgReciveQue, &myobj);
	thread mythread_in(&A::inMsgReciveQue, &myobj);

	mythread_out.join();
	mythread_in.join();

	return 0;
}
```

死锁至少有两个互斥量mutex1，mutex2。

- a.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换。
- b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1.
- c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。

### （2）解决方式

只要保证两个互斥量的顺序一致，就不会发生死锁。



修改上述代码，保证两个互斥量顺序保持一致，就不会发生死锁

### （3）std::lock()函数模板

`std::lock(mutex1,mutex2……);` 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。

如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉

（**要么互斥量都锁住，要么都没锁住，防止死锁**）

能够处理多个互斥量。



```c++
#include<iostream>
#include<thread>
#include<vector>
#include<list>
#include<mutex>

using namespace std;

class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			
			//my_mutex.lock();
			cout << "inMsgReciveQue: " << i << endl;
			{
				//lock_guard<mutex> sbguard(my_mutex);
				//my_mutex1.lock();
				//my_mutex2.lock();
				lock(my_mutex1, my_mutex2);
				msgReciveque.push_back(i);
				my_mutex2.unlock();
				my_mutex1.unlock();

			}

			//my_mutex.unlock();
		}
	}

	bool outMagLULPro(int& command) {
		//lock_guard<mutex> sbguard(my_mutex);		//  lock_guard 构造函数里面 进行lock，析构函数 执行unlock
		//my_mutex1.lock();
		//my_mutex2.lock();
		lock(my_mutex1, my_mutex2);
		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除
			my_mutex1.unlock();
			my_mutex2.unlock();
			return true;
		}
		//my_mutex.unlock();
		my_mutex1.unlock();
		my_mutex2.unlock();
		return false;
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};


int main() {


	A myobj;
	thread mythread_out(&A::outMsgReciveQue, &myobj);
	thread mythread_in(&A::inMsgReciveQue, &myobj);

	mythread_out.join();
	mythread_in.join();

	return 0;
}
```



这样操作，还是需要自己去手动 `unlock`，使用不方便。

### （4）std::lock_guard的std::adopt_lock参数

- `std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);`
- 加入`adopt_lock`后，在调用`lock_guard`的构造函数时，不再进行`lock();`
- `adopt_guard`为结构体对象，起一个标记作用，表示这个互斥量已经`lock()`，不需要在`lock()`。

```c++
class A {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			
			//my_mutex.lock();
			cout << "inMsgReciveQue: " << i << endl;
			{
				//lock_guard<mutex> sbguard(my_mutex);
				//my_mutex1.lock();
				//my_mutex2.lock();
				lock(my_mutex1, my_mutex2);
				lock_guard<mutex> suguard1(my_mutex1, adopt_lock);
				lock_guard<mutex> suguard2(my_mutex2, adopt_lock);
				msgReciveque.push_back(i);
				//my_mutex2.unlock();
				//my_mutex1.unlock();

			}
			//my_mutex.unlock();
		}
	}

	bool outMagLULPro(int& command) {
		//lock_guard<mutex> sbguard(my_mutex);		//  lock_guard 构造函数里面 进行lock，析构函数 执行unlock
		//my_mutex1.lock();
		//my_mutex2.lock();
		lock(my_mutex1, my_mutex2);
		lock_guard<mutex> suguard1(my_mutex1, adopt_lock);
		lock_guard<mutex> suguard2(my_mutex2, adopt_lock);
		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除
			//my_mutex1.unlock();
			//my_mutex2.unlock();
			return true;
		}
		//my_mutex.unlock();
		//my_mutex1.unlock();
		//my_mutex2.unlock();
		return false;
	}

	void outMsgReciveQue(){
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};
```



lambda表达式打印东西

```c++
[]() {cout << "I love china" << endl; }();
```

# 六、unique_lock（类模板）详解

## **1.unique_lock取代lock_guard**

`unique_lock`比`lock_guard`灵活很多（多出来很多用法），效率差一点，内存多一点。
`unique_lock<mutex>  myUniLock(myMutex)`;

下面只展示类内的相关代码：

```c++
class AA {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			cout << "inMsgReciveQue: " << i << endl;
			{
				unique_lock<mutex> myguard(my_mutex1);
				msgReciveque.push_back(i);
			}
		}
	}

	bool outMagLULPro(int& command) {
		
		unique_lock<mutex> myguard(my_mutex1);

		if (!msgReciveque.empty()) {
			int com = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除

			return true;
		}
		return false;
	}

	void outMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(i);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素" << endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};
```

## **2.unique_lock的第二个参数**

### （1）std::adopt_lock：

- 表示这个互斥量已经被`lock()`，即不需要在构造函数中`lock`这个互斥量了。
- 前提：必须提前`lock`
- `lock_guard`中也可以用这个参数



![image-20211227184408449](并发与多线程.assets/image-20211227184408449.png)

### （2）std::try_to_lock：

尝试用`mutex`的`lock()`去锁定这个`mutex`，但如果没有锁定成功，会立即返回，不会阻塞在那里；

使用`try_to_lock`的原因是防止其他的线程锁定`mutex`太长时间，导致本线程一直阻塞在`lock`这个地方（因为本线程一直拿不到锁，一直堵塞在`lock`那个地方）。

前提：不能提前`lock()`;

`owns_locks()`方法判断是否拿到锁，如拿到返回true

```c++
class AA4 {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {

		
			//cout << "inMsgReciveQue: " << i << endl;
			{
				//my_mutex1.lock();
				unique_lock<mutex> myguard(my_mutex1, try_to_lock);
				if (myguard.owns_lock()) {
					cout << "尝试拿锁成功" << endl;
					msgReciveque.push_back(i);
				}
				else
				{
					cout << "尝试拿锁失败" << endl;
				}
				//this_thread::sleep_for(std::chrono::seconds(20));		//	休息 20s

			}
		}
	}

	bool outMagLULPro(int& command) {
		
		lock_guard<mutex> myguard(my_mutex1);
		//my_mutex1.lock();
		this_thread::sleep_for(std::chrono::milliseconds(20000));		//	休息 20s

		if (!msgReciveque.empty()) {
			command = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除

			return true;
		}
		return false;
	}

	void outMsgReciveQue() {
		int command = 0;
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(command);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素: " <<command<< endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};
```



尝试去拿锁，拿不到锁，直接返回，不会卡死在`lock`那边



### （3）std::defer_lock：

- 如果没有第二个参数就对`mutex`进行加锁，加上`defer_lock`是始化了一个没有加锁的`mutex`
- 不给它加锁的目的是以后可以调用`unique_lock`的一些方法
- 前提：不能提前`lock`



### 3.unique_lock的成员函数

### （1）lock 加锁

![image-20211227194709499](并发与多线程.assets/image-20211227194709499.png)



不用自己`unlock()`;



### （2）unlock 解锁

```c++
class AA4 {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {

		
			cout << "inMsgReciveQue: " << i << endl;
			{
				//my_mutex1.lock();
				unique_lock<mutex> myguard(my_mutex1, defer_lock);

				myguard.lock();		// 不用自己unlock
				
				myguard.unlock();

				// 处理非共享代码；  先把锁释放出来 让别的线程能够拿到这个锁

				myguard.lock();

				msgReciveque.push_back(i);
				//this_thread::sleep_for(std::chrono::seconds(20));		//	休息 20s

			}
		}
	}

	bool outMagLULPro(int& command) {
		
		lock_guard<mutex> myguard(my_mutex1);
		//my_mutex1.lock();
		this_thread::sleep_for(std::chrono::milliseconds(200));		//	休息 20s

		if (!msgReciveque.empty()) {
			command = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除

			return true;
		}
		return false;
	}

	void outMsgReciveQue() {
		int command = 0;
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(command);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素: " <<command<< endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};
```



因为一些非共享代码要处理，可以暂时先`unlock()`，用其他线程把它们处理了，处理完后再`lock()`。



### （3）try_lock 尝试加锁



```c++
class AA4 {

public:
	void inMsgReciveQue() {
		for (int i = 0; i < 1000; i++) {	
			{
				//my_mutex1.lock();
				unique_lock<mutex> myguard(my_mutex1, defer_lock);

				//myguard.lock();		// 不用自己unlock
				
				//myguard.unlock();

				// 处理非共享代码；  先把锁释放出来 让别的线程能够拿到这个锁

				//myguard.lock();
				if (myguard.try_lock() == true) {
					cout << "inMsgReciveQue: " << i << endl;
					msgReciveque.push_back(i);
				}
				else {
					cout << "没拿到锁，干点别的事" << endl;
				}				
				//this_thread::sleep_for(std::chrono::seconds(20));		//	休息 20s
			}
		}
	}

	bool outMagLULPro(int& command) {
		
		lock_guard<mutex> myguard(my_mutex1);
		//my_mutex1.lock();
		this_thread::sleep_for(std::chrono::milliseconds(200));		//	休息 20s

		if (!msgReciveque.empty()) {
			command = msgReciveque.front();  // 取元素
			msgReciveque.pop_front();		// 消除

			return true;
		}
		return false;
	}

	void outMsgReciveQue() {
		int command = 0;
		for (int i = 0; i < 1000; i++) {
			bool result = outMagLULPro(command);
			if (result == true) {
				cout << "outMagLULPro(),从队列中取出一个元素: " <<command<< endl;
			}
			else {
				cout << "outMagLULPro(),执行，但队列为空" << endl;
			}
		}
	}

private:
	list<int> msgReciveque;
	mutex my_mutex1;
	mutex my_mutex2;
};
```





### （4）release()：

`unique_lock<mutex> myUniLock(myMutex)`;相当于把`myMutex`和`myUniLock`绑定在了一起；

`release()`就是解除绑定，返回它所管理的`mutex`对象的指针，并释放所有权

`mutex* ptx  = myUniLock.release()`;所有权由`ptx`接管，如果原来mutex对象处理加锁状态，就需要`ptx`在以后进行解锁了。

`lock`的代码段越少，执行越快，整个程序的运行效率越高。

- a.锁住的代码少，叫做粒度细，执行效率高；
- b.锁住的代码多，叫做粒度粗，执行效率低；

![image-20211227201937559](并发与多线程.assets/image-20211227201937559.png)



### 4.unique_lock所有权的传递

`unique_lock<mutex>  myUniLock(myMutex)`;把`myMutex`和`myUniLock`绑定在了一起，也就是`myUniLock`拥有`myMutex`的所有权

1. 使用`move`转移

`myUniLock`拥有`myMutex`的所有权，`myUniLock`可以把自己对`myMutex`的所有权转移，但是不能复制。

`unique_lock<mutex>  myUniLock2(std::move(myUniLock))`;

现在`myUniLock2`拥有`myMutex`的所有权。



![image-20211227203925537](并发与多线程.assets/image-20211227203925537.png)







​	2. 在函数中`return`一个临时变量，即可以实现转移

```c++
unique_lock<mutex> aFunction()
{
    unique_lock<mutex> myUniLock(myMutex);
    //移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的
    //返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数
    return myUniLock;
}
// 然后就可以在外层调用，在sbguard具有对myMutex的所有权
std::unique_lock<std::mutex> sbguard = aFunction();

```

# 七、 单例设计模式共享数据分析、解决，call_once

## **1.设计模式**

- 程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦
- 老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式
- 中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置
- 设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套





## **2.单例设计模式：**

- 整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。
- 单例类：只能生成一个对象。



```c++
#include<iostream>
#include<thread>

// 单例类
class MyCAS {
private:
	MyCAS(){}		// 私有化构造函数   // 类外不能创建

private:
	static MyCAS* instatic;		// 静态成员变量

public:

	static MyCAS* getInstance() {

		if (instatic == nullptr) {
			instatic = new MyCAS();		//new 出来的，何时释放
			static CGarhuisou cl;    
		}	
		return instatic;
	}

	class CGarhuisou {		//	类中套类，用于释放对象

	public:
		~CGarhuisou()
		{
			if (MyCAS::instatic) {
				delete MyCAS::instatic;
				MyCAS::instatic = nullptr;
			}
		}

	};

	void func() {

		std::cout << "测试：" << std::endl;
	}
};

MyCAS* MyCAS::instatic = nullptr;		// 静态成员函数类外初始化

int main() {

	MyCAS* p_a = MyCAS::getInstance();  // 静态成员函数可以通过 类名直接访问
	MyCAS* p_b = MyCAS::getInstance();

	p_a->func();

	MyCAS::getInstance()->func();

	return 0;
}
```



`MyCAS* p_a = MyCAS::getInstance()`; 
`MyCAS* p_b = MyCAS::getInstance()`;

这里虽然写了两个创建，类成员变量的代码，只能创建出来一个对象。他们的地址是相同的

![image-20211228103928133](并发与多线程.assets/image-20211228103928133.png)







## **3.单例设计模式共享数据分析、解决**

面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。

我们可能面临`GetInstance()`这种成员函数需要互斥。



由于`CPU`的切换，存在两个线程同时执行到`new`的那一行的情况，这就会出现`bug`



```c++
#include<iostream>
#include<thread>
#include<mutex>

// 单例类

std::mutex resource_mutex;

class MyCAS {
private:
	MyCAS(){}		// 私有化构造函数   // 类外不能创建

private:
	static MyCAS* instatic;		// 静态成员函数

public:

	static MyCAS* getInstance() {

		std::unique_lock<std::mutex> mymutex(resource_mutex);  //  主动解锁

		if (instatic == nullptr) {
			instatic = new MyCAS();
			static CGarhuisou cl;
		}	
		return instatic;
	}

	class CGarhuisou {		//	类中套类，用于释放对象
	public:
		~CGarhuisou()
		{
			if (MyCAS::instatic) {
				delete MyCAS::instatic;
				MyCAS::instatic = nullptr;
			}
		}

	};

	void func() {

		std::cout << "测试：" << std::endl;
	}
};

MyCAS* MyCAS::instatic = nullptr;		// 静态成员函数类外初始化

void mythread() {		//	线程入口函数
	std::cout << "我的线程开始执行了" << std::endl;
	MyCAS* p_a = MyCAS::getInstance();
	std::cout << "我的线程结束了" << std::endl;
	return;
}

int main() {
    
	std::thread thread1(mythread);
	std::thread thread2(mythread);

	thread1.join();
	thread2.join();

	return 0;
}
```



直接在创建这个类前面加上`std::unique_lock<std::mutex> mymutex(resource_mutex)`;，达到一个互斥的作用，这样就可以解决创建的问题。

在不同的线程创建的 **单例类** 的地址还是一样的。我们可以看到 `p_a` 指针的值是一样

![image-20211228120942795](并发与多线程.assets/image-20211228120942795.png)

但这样还有一个问题，就是我要

可以在加锁前判断`instance`是否为空，否则每次调用`MyCAS::getInstance()`都要加锁，十分影响效率。

比如另一个线程中也要实例化一个单例类对象，然后调用成员函数



```c++
#include<iostream>
#include<thread>
#include<mutex>

// 单例类

std::mutex resource_mutex;

class MyCAS {
private:
	MyCAS(){}		// 私有化构造函数   // 类外不能创建

private:
	static MyCAS* instatic;		// 静态成员函数

public:

	static MyCAS* getInstance() {

		if (instatic == nullptr) {   //双层锁定，以提高效率
			
			std::unique_lock<std::mutex> mymutex(resource_mutex);  //  主动解锁

			if (instatic == nullptr) {
				instatic = new MyCAS();
				static CGarhuisou cl;
			}
		}
		return instatic;
	}

	class CGarhuisou {		//	类中套类，用于释放对象

	public:
		~CGarhuisou()
		{
			if (MyCAS::instatic) {
				delete MyCAS::instatic;
				MyCAS::instatic = nullptr;
			}
		}

	};

	void func() {

		std::cout << "测试：" << std::endl;
	}
};

MyCAS* MyCAS::instatic = nullptr;		// 静态成员函数类外初始化

void mythread() {		//	线程入口函数
	std::cout << "我的线程开始执行了" << std::endl;
	MyCAS* p_a = MyCAS::getInstance();
	std::cout << "线程ID: " << std::this_thread::get_id() << " p_a指针的值: " << p_a << std::endl;
	std::cout << "我的线程结束了" << std::endl;
	return;
}

int main() {
	std::thread thread1(mythread);
	std::thread thread2(mythread);

	thread1.join();
	thread2.join();


	MyCAS* p_a = MyCAS::getInstance();
	std::cout << "主线程线程ID: " << std::this_thread::get_id() << " p_a指针的值: " << p_a << std::endl;
	p_a->func();

	return 0;
}
```



只有多个线程同时初始化`instance`的时候，才会执行到**加锁**那一步，初始化成功了，就再也不会执行那一步了



这样创建的3个`p_a`的地址是一样的。





## 4.std::call_once()：

函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。
功能：能够保证函数a()只被调用一次。具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。
call_once()需要与一个标记结合使用，这个标记为std::once_flag；其实once_flag是一个结构，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。

多个线程同时执行时，一个线程会等待另一个线程先执行。

```c++
#include<iostream>
#include<thread>
#include<mutex>

// 单例类

std::mutex resource_mutex;
std::once_flag o_flag;

class MyCAS {

	static void CreatInstance() {

		std::cout << "CreatInstance()执行" << std::endl;
		instatic = new MyCAS();
		static CGarhuisou cl;
	}

private:
	MyCAS(){}		// 私有化构造函数   // 类外不能创建

private:
	static MyCAS* instatic;		// 静态成员函数

public:

	static MyCAS* getInstance() {

		//if (instatic == nullptr) {   //双层锁定，以提高效率
		//	
		//	std::unique_lock<std::mutex> mymutex(resource_mutex);  //  主动解锁

		//	if (instatic == nullptr) {
		//		instatic = new MyCAS();
		//		static CGarhuisou cl;
		//	}
		//}

		std::call_once(o_flag, CreatInstance);		// callonce 相当于 一个互斥锁，保证这个函数只能被执行一次。

		return instatic;
	}

	class CGarhuisou {		//	类中套类，用于释放对象

	public:
		~CGarhuisou()
		{
			if (MyCAS::instatic) {
				delete MyCAS::instatic;
				MyCAS::instatic = nullptr;
			}
		}

	};

	void func() {

		std::cout << "测试：" << std::endl;
	}
};

MyCAS* MyCAS::instatic = nullptr;		// 静态成员函数类外初始化

void mythread() {		//	线程入口函数
	std::cout << "我的线程开始执行了" << std::endl;
	MyCAS* p_a = MyCAS::getInstance();
	std::cout << "线程ID: " << std::this_thread::get_id() << " p_a指针的值: " << p_a << std::endl;
	std::cout << "我的线程结束了" << std::endl;
	return;
}

int main() {
	std::thread thread1(mythread);
	std::thread thread2(mythread);

	thread1.join();
	thread2.join();


	MyCAS* p_a = MyCAS::getInstance();
	std::cout << "主线程线程ID: " << std::this_thread::get_id() << " p_a指针的值: " << p_a << std::endl;
	p_a->func();

	return 0;
}
```



# 八、 condition_variable、wait()、notify_one、notify_all

## 1.条件变量condition_variable、wait、notify_one、notify_all

`std::condition_variable`实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。

```c++
std::mutex mymutex1;
std::unique_lock<std::mutex> sbguard1(mymutex1);
std::condition_variable condition;
condition.wait(sbguard1, [this] {if (!msgRecvQueue.empty())
                                    return true;
                                return false;
                                });
 
condition.wait(sbguard1);

```



`wait()`用来等一个东西

如果第二个参数的`lambda`表达式返回值是`false`，那么`wait()`将**解锁互斥量**(不锁定)，并阻塞到本行
如果第二个参数的`lambda`表达式返回值是`true`，那么`wait()`直接返回并继续执行。

阻塞到什么时候为止呢？阻塞到其他某个线程调用`notify_one()`成员函数为止；

如果没有第二个参数，那么效果跟第二个参数`lambda`表达式返回`false`效果一样

`wait()`将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用`notify_one()`成员函数为止。

当其他线程用`notify_one()`将本线程`wait()`唤醒后，这个`wait`恢复后



1、wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁

2.1、如果wait有第二个参数就判断这个lambda表达式。

a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒
b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。
2.2、如果wait没有第二个参数，则wait返回，流程走下去。

流程只要走到了wait()下面则互斥量一定被锁住了。



```c++
#include <thread>
#include <iostream>
#include <list>
#include <mutex>
using namespace std;
 
class A {
public:
    void inMsgRecvQueue() {
        for (int i = 0; i < 100000; ++i) 
        {
            cout << "inMsgRecvQueue插入一个元素" << i << endl;

            std::unique_lock<std::mutex> sbguard1(mymutex1);
            msgRecvQueue.push_back(i); 
            //尝试把wait()线程唤醒,执行完这行，
            //那么outMsgRecvQueue()里的wait就会被唤醒
            //只有当另外一个线程正在执行wait()时notify_one()才会起效，否则没有作用
            condition.notify_one();
        }
	}
 
	void outMsgRecvQueue() {
        int command = 0;
        while (true) {
            std::unique_lock<std::mutex> sbguard2(mymutex1);
            // wait()用来等一个东西
            // 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行
            // 阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；
            //当 wait() 被 notify_one() 激活时，会先执行它的 条件判断表达式 是否为 true，
            //如果为true才会继续往下执行
            condition.wait(sbguard2, [this] {
                if (!msgRecvQueue.empty())
                    return true;
                return false;});
            command = msgRecvQueue.front();
            msgRecvQueue.pop_front();
            //因为unique_lock的灵活性，我们可以随时unlock，以免锁住太长时间
            sbguard2.unlock(); 
            cout << "outMsgRecvQueue()执行，取出第一个元素" << endl;
            
            // 解锁之后就可以指向非共享的数据代码，别的线程也能够拿到锁，提高效率。
            
        }
	}
 
private:
	std::list<int> msgRecvQueue;
	std::mutex mymutex1;
	std::condition_variable condition;
};
 
int main() {
	A myobja;
	std::thread myoutobj(&A::outMsgRecvQueue, &myobja);
	std::thread myinobj(&A::inMsgRecvQueue, &myobja);
	myinobj.join();
	myoutobj.join();
}

```



## 2.深入思考

上面的代码可能导致出现一种情况：
因为`outMsgRecvQueue()`与`inMsgRecvQueue()`并不是一对一执行的，所以当程序循环执行很多次以后，可能在`msgRecvQueue` 中已经有了很多消息，但是，`outMsgRecvQueue`还是被唤醒一次只处理一条数据。这时可以考虑把`outMsgRecvQueue`多执行几次，或者对`inMsgRecvQueue`进行限流。



## 3.notify_all()

- `notify_one()`：通知一个线程的`wait()`
- `notify_all(`)：通知所有线程的`wait()`



```c++
#include<iostream>
#include<vector>
#include<thread>
#include<list>
#include<mutex>


using namespace std;

class AA6 {

public:
	void inMsgRecvList() {
		for (int i = 0; i < 10000; i++) {
			

			unique_lock<mutex> mylock(mymutex);
			cout << "往队列中插入一个元素：" << i << endl;
			msgRecvList.push_back(i);

			my_cond.notify_all(); // 我们尝试把wait的线程唤醒；
		}
		return;
	}
	
	//bool msgRecvListTest(int& command) {
	//	unique_lock<mutex> mylock(mymutex);
	//	if (!msgRecvList.empty()) {
	//		command = msgRecvList.front();
	//		msgRecvList.pop_front();
	//		return true;
	//	}
	//	return false;
	//}

	void outMsgRecvList() {
		int command = 0;
		//for (int i = 0; i < 10000; i++) {
		//	if (msgRecvListTest(command) == true) {
		//		cout << "从队列中取出一个元素：" << command << endl;
		//	}
		//	else {
		//		cout << "队列为空，不进行操作" << i<<endl;
		//	}
		//}
		while (true) {
			unique_lock<mutex> mylock(mymutex);

			// wait()用来等一个东西
			// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行
			// 阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；
			//当 wait() 被 notify_one() 激活时，会先执行它的 条件判断表达式 是否为 true，
			//如果为true才会继续往下执行

			my_cond.wait(mylock, [this] {
				if (!msgRecvList.empty())
					return true;
				return false;
				});

			// 流程只要能走到这边，一定是锁着的；
			command = msgRecvList.front();
			msgRecvList.pop_front();

			cout << "outMsgRecvList()执行，取出一个元素" << command << " 线程ID："<<this_thread::get_id() << endl;
			mylock.unlock();   // 提前解锁，让其他线程能够处理；
			

			// 执行一些其他动作，，假设需要 100ms
			// 上面那个锁已经放开，其他线程获取到锁，又尝试唤醒，这个时候程序在这边执行，，则唤醒失败（不是卡在 wait() 那边）
			// 这个时候notify_one 就没有效果

			//if (msgRecvList.empty()) break;

		}

	}

private:
	list<int> msgRecvList;
	mutex mymutex;
	condition_variable my_cond;  // 条件变量
};


int main() {
	AA6 myobj;
	thread my_thread1(&AA6::outMsgRecvList, &myobj);
	thread my_thread1_1(&AA6::outMsgRecvList, &myobj);
	thread my_thread2(&AA6::inMsgRecvList, &myobj);

	my_thread1.join();
	my_thread1_1.join();
	my_thread2.join();

	cout << "I love china  " << this_thread::get_id() << endl;

	return 0;
}
```



```c++
my_cond.notify_all(); // 我们尝试把wait的线程唤醒；
```



这里利用两个线程进行`out`，用`notify_all()`和`notify_once()`，结果是一样的，因为唤醒之后，两个线程还要竞争锁，只能一个线程工作。



# 九、async、future、packaged_task、promise

## 1.std::async、std::future创建后台任务并返回值

**`std::async`**是一个函数模板，用来启动一个**异步任务**，启动起来一个异步任务之后，它返回一个**`std::future`**对象，这个对象是个类模板。



什么叫“启动一个异步任务”？就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个`std::future`对象，这个`std::future`对象中就含有线程入口函数所返回的结果，我们可以通过调用`future`对象的成员函数`get()`来获取结果。

“future”将来的意思，也有人称呼`std::future`提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：`future`中保存着一个值，这个值是在将来的某个时刻能够拿到。

`std::future`对象的`get()`成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像`join()`。但是，它是可以获取结果的。

`std::future`对象的`wait()`成员函数，用于等待线程返回，本身并不返回结果，这个效果和 `std::thread` 的`join()`更像。



普通函数做线程入口函数

```c++
#include<iostream>	
#include<vector>
#include<chrono>
#include<memory>
#include<future>

using namespace std;

int mythread() {
	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	std::this_thread::sleep_for(std::chrono::seconds(5));

	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	
	return 5;
}

int main() {

	cout << "main() " << " 线程ID: " << this_thread::get_id() << endl;

	std::future<int> result = std::async(mythread);	//创建一个线程，绑定关系

	cout << "continue....." << endl;

	int def;
	def = 0;
	cout << result.get() << endl;	// 卡在这里 等待 mythread() 执行完毕，拿到结果
	//result.wait();
	cout << "I Love Chine" << endl;

	system("pause");
	return 0;
}
```



类成员函数做线程入口函数



```c++
#include<iostream>	
#include<vector>
#include<chrono>
#include<memory>
#include<future>

using namespace std;

class AA7 {

public:
	AA7() {
		this->val = 7;
	}
	int mythread(int num) {
		cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
		std::this_thread::sleep_for(std::chrono::seconds(5));

		cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;

		return num;
	}
public:
	int val;
};

int mythread() {
	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	std::this_thread::sleep_for(std::chrono::seconds(5));

	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	
	return 5;
}

int main() {

	cout << "main() " << " 线程ID: " << this_thread::get_id() << endl;

	// 类成员函数做线程入口函数
	AA7 myobja;
	int temmper = 12;
	std::future<int>result2 = std::async(&AA7::mythread, &myobja, temmper);

	cout << "continue....." << endl;

	cout << result2.get() << endl;	// 卡在这里 等待 mythread() 执行完毕，拿到结果
	//result.wait();
	cout << "I Love Chine,2" << endl;


	system("pause");
	return 0;
}
```



我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：

### （1）std::launch::deferred

（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；如果wait()或者get()没有被调用，则不会执行。
实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，要在get(),或者是wait()处才开始调用线程入口函数。

但是并没有创建新的线程，因为与主线程的线程ID一样



```c++
#include<iostream>	
#include<vector>
#include<chrono>
#include<memory>
#include<future>

using namespace std;

class AA7 {

public:
	AA7() {
		this->val = 7;
	}
	int mythread(int num) {
		cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
		//std::this_thread::sleep_for(std::chrono::seconds(5));

		cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;

		return num;
	}
public:
	int val;
};

int mythread() {
	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	//std::this_thread::sleep_for(std::chrono::seconds(5));

	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	
	return 5;
}

int main() {

	// 类成员函数做线程入口函数
	AA7 myobja;
	int temmper = 12;
	std::future<int>result2 = std::async(std::launch::deferred,&AA7::mythread, &myobja, temmper);

	cout << "continue....." << endl;

	cout << result2.get() << endl;	// 卡在这里 等待 mythread() 执行完毕，拿到结果
	//result.wait();
	cout << "I Love Chine,2" << endl;


	system("pause");
	return 0;
}
```

![image-20220110142656341](并发与多线程.assets/image-20220110142656341.png)



表示线程是在主线程中执行的，并没有创建新的线程。是在主线程中调用的线程入口函数。



### （2）std::launch::async

在调用async函数的时候就开始创建新线程。

**系统默认使用这个标记**，与不使用这个标记一样的结果。

![image-20220110143349941](并发与多线程.assets/image-20220110143349941.png)

线程ID不一样，证明创建了一个新线程。





## 2.std::packaged_task

**打包任务，把任务包装起来。**

类模板，它的模板参数是各种可调用对象，通过`packaged_task`把各种可调用对象包装起来，方便将来作为线程入口函数来调用。

```c++
#include <thread>
#include <iostream>
#include <future>
using namespace std;
 
int mythread(int mypar) {
	cout << mypar << endl;
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}
 
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	//我们把函数mythread通过packaged_task包装起来
    //参数是一个int，返回值类型是int
    std::packaged_task<int(int)> mypt(mythread);
	std::thread t1(std::ref(mypt), 1);
	t1.join();
	std::future<int> result = mypt.get_future(); 
	//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
	cout << result.get() << endl;
   
	return 0;
}

```



**可调用对象可由函数换成lambda表达式**

```c++
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::packaged_task<int(int)> mypt([](int mypar) {
		cout << mypar << endl;
		cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
		std::chrono::milliseconds dura(5000);
		std::this_thread::sleep_for(dura);
		cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
		return 5;
	}); 
	
	std::thread t1(std::ref(mypt), 1);
	t1.join();
	std::future<int> result = mypt.get_future(); 
	//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
	
	cout << result.get() << endl;
 
	cout << "good luck" << endl;
	return 0;
}

```





`packaged_task`包装起来的可调用对象还可以直接调用，从这个角度来讲，`packaged_task`对象也是一个可调用对象
*`lambda`的直接调用*

```c++
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::packaged_task<int(int)> mypt([](int mypar) {
		cout << mypar << endl;
		cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
		std::chrono::milliseconds dura(5000);
		std::this_thread::sleep_for(dura);
		cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
		return 5;
	}); 
 
	mypt(1);
	std::future<int> result = mypt.get_future();
	cout << result.get() << endl;
}

```

![image-20220110151336746](并发与多线程.assets/image-20220110151336746.png)



通过这种方式是在主线程中**调用**线程入口函数。线程ID一样



## 3.std::promise

类模板
我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来

```c++
#include<iostream>	
#include<vector>
#include<chrono>
#include<memory>
#include<future>
#include<thread>

using namespace std;

void mythread2(std::promise<int>& res, int cal) {
	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	cout << cal << endl;
	cal++;
	cal *= 10;
	std::this_thread::sleep_for(std::chrono::seconds(5));
	int result = cal;
	res.set_value(result);
	cout << "mythread() end" << " 线程ID: " << this_thread::get_id() << endl;
	return;
}

void mythread3(std::future<int>& temf) {
	cout << "mythread() start" << " 线程ID: " << this_thread::get_id() << endl;
	auto result = temf.get();
	cout << "result： " << result << endl;
	cout << "mythread() end" << " 线程ID: " << this_thread::get_id() << endl;
	return;
}


int main() {

	cout << "main() " << " 线程ID: " << this_thread::get_id() << endl;

	std::promise<int> mypro;
	std::thread t1(mythread2, std::ref(mypro), 12);
	t1.join();

	// 获取结果值
	std::future<int> result = mypro.get_future();  //future 绑定这个promise

	std::thread t2(mythread3, std::ref(result));

	t2.join();
	//cout << result.get() << endl;
	cout << "I Love Chine" << endl;

	system("pause");
	return 0;
}
```

总结：通过`promise`保存一个值，在将来某个时刻我们通过把一个`future`绑定到这个`promise`上，来得到绑定的值

注意：使用`thread`时，必须 `join()` 或者 `detach()` 否则程序会报异常
